Readme file for RAISHIN-GRMHD version

Developed by Yosuke Mizuno
                      ITP/Goethe Univ. Frankfurt (mizunoys@th.physik.uni-frankfurt.de)
                      
RAISHIN ver. 150925

RAISHIN code is used a conservative finite volume shock-capturing schemes (Gudonov-type schemes) to solving the hyperbolic partial differential equations (PDE). This version of code is specialized for solving 3D ideal general relativistic magnetohydrodynamics (3DGRMHD) using 3D MPI parallelization based on the formulation used in Gammie et al.(2003).

Including files: 
README_GRMHD.txt: This file, general documentation
Makefile: makefile for main exec, data and convert for data analysis 

# Main computation programs

main.f90: Primary routine
pram.f90: module file for general parameter set
bnd.f90: Boundary condition
calcha.f90: Subroutines for calculation of characteristics
calflx.f90: Subroutines for calculation of numerical flux (not Riemann solver)
calsf.f90: Subroutines for calculation of source term
caluu.f90: Subroutines for calculation of conserved variables
cdtcfl.f90: Subroutines for calculation of dt from CFL condition
coord.f90: Subroutines for calculation of metrics & christfel symbols
correction.f90: Subroutines for numerical treatment (atmosphere, floor, damping etc.)
ct.f90: Subroutines for constrained transport schemes
func.f90: General functions using RAISHIN code
grfunc.f90: Functions for GR calculations (not used => merged to physfunc.f90)
grid.f90: Set for making grid
hll.f90: Subroutines for Approximate Riemann solver schemes
mdgrmhd.f90: Subroutines for Initial setup of each models
mpisub.f90: Subroutines for MPI
physfunc.f90: Functions for GR calculations
rec.f90: Subroutines for reconstruction schemes
recov.f90: Subroutines for inversion procedure schemes
restar.f90: Subroutines for restart
rkt.f90: Subroutines for time advance schemes

# Rearrange of data for analysis
convert_idl.f90: Post-process routines for data rearranging (for IDL)
convert_vtk.f90: Post-process routines for data rearranging (for VISIT, mostly used)
convert_rad.f90: Porst-process routines for data rearranging (for radiation image, BHCam project)

START RUNNING:

First copy of makefile:
>cp Makefile_xgrmhd Makefile

Then make a exec file:
>make

Please change using compiler and compiler option for your running computers.

Running exec files: 
>./xgrmhd

Example:
Running Mac OS X using gfortran with MPI. In makefile, using
FC = mpif90
FFLAGS = -O2 -Wall
For running exec files,
> mpiexec -n X ./xgrmhd (using X cpus)

The following files will be generated by RAISHIN code:

--./restart[000-NNN].outdat: output data for restart from each cpu. [000-NNN] is cpu number
---./structr[000-NNN]_[000-MMM].outdat: output data for data analysis from each cpu and each output time
---./structr1[000-NNN]_[000-MMM].outdat: output data for radiation image from each cpu ([000-NNN]) and each output time ([000-MMM]).

Restart simulations:

The RASHIN code is handling the simulation from using computer time (icpu), maximum number of iteration (itmax), or Maximum simulation time (tmax). If the cpu time reachs maximum before maximum simulation time, the simulation is stopped. Therefore we need to restart the simulations. When the simulation restarts, you set "icres=1" in pram.f90 and make the exec again (need "make clean"). Then restart the simulation.   

Rearrange data set for data analysis:

After making one data file (structr.outdat), we use additional procedure of making data files for IDL and for VISIT. 

>cp Makefile_convert Makefile
>make
>./xkamt

In convert_vtk*.f90 we convert from 3D data (x1,x2,x3) to 2D (or 3D) from choosing functions. The making "ok#.vtk" is data set (vtk regacy format-ascii data) for each time step. Related parameter is written in the same program. 
nh: total number of output files
ns: start (reading) output file number
dataformat: dataformat for vtk file
idirec: output direction (combination of 1=x, 2=y, 3=z)

CHANGING INITIAL CONDITION:

For changing simulation size, time, model etc, you change parameters in pram.f90. The parameter in pram.f90 is following:

 imax=128, jmax=7, kmax=256 !Grid number

 iprocs=2, jprocs=1, kprocs=2 !CPU number in i- j- and k- directions, total number of cpus are npe=iprocs*jprocs*kprocs

 icpu=20000 ! CPU time (second)

 itmax=1000000 ! Max number of iteration

 nshot=1 ! Number of Output 

 icres=0 ! Researt parameter
!     icres = 0  : restart off
!     icres = 1  : restart on

dtmin=1.0d-9 ! Minimum dt (if dt < dtmin, simulation is stop)
 
 tmax=1.0d0 ! Maximum simulation time

 cfl=0.3d0 ! CFL number

 pmin=1.0d-20, pmax=1.0d10, dmin=1.0d-10 ! limiter (floor) for minimum and maximum pressure and minimum density

 gam=5.0d0/3.0d0 ! adiabatic index

  rbh=1.d0 ! black hole radius rg=GM/c^2
  akm=0.d0 ! black hole spin
  
 xmin, xmax, ymin, ymax, zmin, zmax: maxmim and minmum position for x1-, x2-, and x3-directions (normalized by shwarzschild radius)

 ix1=1, ix2=1, rix3=1 ! grid spacing
!ix1 = 1 : uniform grid in radial direction
!ix1 = 2 : logarithmic grid spacing in radial direction  

R0=0.d0, hslope=0.4d0 ! parameter for grid spacing

 model=1 ! simulation model
!
!      model=1 : 1D test (put const. density and pressure)
!      model=2 : 1D shock-tube test
!      model=3 : GR free-fall accretion model
!      model=7 : GR geometrically thick torus model (Fisbone-Moncriff model)
!      model=8 : GR geometrically thick torus model (De Villiers et al. 2003, power-law rotating torus)
!     model=9 : GR geometrically thick torus model (Font & Daigne 2002, constant l model)
!     model=12 : GR geometrically thick magnetized torus model (Komissarov 2006)
!     model=10 : GR recoiling BH model (Zanotti et al. 2010)
!     model=13 : GR recoiling BH model + thick magnetized torus model
!     model=14 : tilted disk model (Fragile & Anninos 2005)
!     model=15 : tilted disk model ver.2 (not perfect)
!     model=31 : wind-wind collision model

 metric=203 ! metric
! Mertic (coordinates) 
!
!     metric =  1 : Minkowski cartesian spacetime (SR)
!     metric =  3 : Minkowski spherical spacetime  (SR)
!     metric =  103 :  Schwarzschild BH in Boyer-Lindquist corrdinates
!     metric =  203 :  Kerr BH in Boyer-Lindquist corrdinates
!     metric =  303 :  Kerr BH in Kerr-Schild coordinates
!     metric =  403 :  Modified Kerr-Schild coordinates (need to set "ix1=2" and "ix3=2")
!     metric =  503 :  Kerr BH in tilted Kerr-Schild coordinates 
!

 ieos=0 ! EoS
! Equation of State
!
!     ieos=0 : Gamma-law constant equation of state    
!     ieos=1 : TM variable equation of state (cal enthalpy) 
!     ieos=2 : TM variable equation of state (cal internal energy) (not perfect yet)
!     ieos=3 : Polytropic equation of state (not perfect?)

 icha=1! calculation method for wave speed

 irec=1 ! reconstruction scheme
! Reconstruction scheme
!
!     irec = 1 : MC slope-limiter reconstruction (2nd order)
!     irec = 2 : Minmod slope-limiter reconstruction (2nd order)
!     irec = 3 : MUSCL method (3rd order), not slope-limiter
!     irec = 4 : Convex ENO reconstruction method (3rd order)
!     irec = 5 : rPPM reconstruction method (4th order)
!     irec = 6 : Monotonicity-Preserving 5th reconstruction (5th order)
!     irec = 7 : Weighted ENO 5th reconstruction (5th order)
!     irec = 8 : MP-WENO reconstruction
!     irec = 9 : WENO-Z 5th reconstruction
!     irec = 10: Mapped WENO 5th reconstruction
!     irec = 11: Limited Reconstruction (3rd order)

 ihll=1 ! Approximate Riemann solver scheme
! Approximate Riemann solver scheme
!
!     ihll = 1 : HLLE single-state approximate Riemann solver

 ict=1  ! Constrained Transport scheme
! Constrained Transport scheme
!
!     ict = 0 : No contrained transport
!     ict = 1 : Flux CT sheme (Toth 2000)
!     ict = 2 : Modified Flux CT scheme (Gardiner & Stone 2005)
!     ict = 3 : Upwind Flux CT scheme (Gardiner & Stone 2005)
!

 irkt=3 ! time-advance
! RK time advance scheme
!
!     irkt = 2 : 2nd order TVD Runge-Kutta time advance method
!     irkt = 3 : 3rd order TVD Runge-Kutta time advance method
!
  
 iwvec=1 ! inversion procedure
! Inversion procedure scheme
!
!     iwvec=1 : 2 variable newton-raphson (from Noble et al. 2005)
!     iwvec=2 : 1 variable newton-raphson with variable EOS
!                      (from Mignone & McKinney 2007) 
!     iwvec=3 : 1 variable newton-raphson (from Noble et al. 2005)
!     iwvec=4 : 1 variable newton-raphson for Polytropic EoS

 iboux1in(9)=(/7, 7, 7, 7, 7, 7, 7, 7, 7/) ! boundary condition for x1-inner
 iboux1ot(9)=(/5, 5, 5, 5, 5, 5, 5, 5, 5/) ! boundary condition for x1-outer
 iboux2in(9)=(/1, 1, 1, 1, 1, 1, 1, 1, 1/) ! boundary condition for x2-inner
 iboux2ot(9)=(/1, 1, 1, 1, 1, 1, 1, 1, 1/) ! boundary condition for x2-outer
 iboux3in(9)=(/1, 1, 1, 1, 1, 1, 1, 1, 1/) ! boundary condition for x3-inner
 iboux3ot(9)=(/1, 1, 1, 1, 1, 1, 1, 1, 1/) ! boundary condition for x3-outer 
! Boundary Condiiton
!
!               1   :    periodic boundary
!               2   :    fixed boundary
!               3   :    Neumann boundary
!               4   :    free boundary
!               5   :    u_0 = u_1       
!               7   :    radiative boundary without eigenvalue
!              12   :    anti-symmetric boundary condition (u_0=-u_1)
!              13   :    regid wall boundary condition (u_0=0.0)
!              15   :    special reflecting boundary 
!                        for jet propagation (z-direction only)
!              17   :    special radiative boundary without eigenvalue
!                        for jet propagation (z-direction only)
!              19   :    special boundary of u_0=u_1
!                        for jet propagation (z-direction only)
 
For changing simulation model, you change parameters in each subroutines of "mdgrmhd.f90".

RUNNING 1D or 2D:

If you want to run 1D or 2D model in this 3D code, you set minimum number of grid in x2 and/or x3 directions. Mimimum number of grid depends on choosing schemes. In general minimum number of grid = 2*nm1+1. "nm1" is found in "main.f90" (depend on choosing each schemes).  And number of cpus set 1 (jpocs and/or kprocs in "pram.f90"). We usually use x1-direction in 1D model and x1- & x3-directions in 2D model.

DATA ANALYSIS

I mostly use IDL for 1D and VISIT for 2D & 3D data analysis.

# analysis program for IDL
dread.pro: data read program
vonx1d.pro: 1D plot on x-direction
plfccnve2D.pro: 2D plot (color contour + line contour + vector)
video.pro: movie for 2D plot

USING IDL:

#For 1D plot
IDL> .r dread
IDL> .r vonx1D

#For 2D plot
IDL> .r dread
IDL> .r plfccnve2D


If you want to put the data on ps file, please choose plot_choice='ps' (for 1D plot), or plot_choice='cps' (for 2D plot) in "vonx1D.pro" or "plfccnve2D.pro".

